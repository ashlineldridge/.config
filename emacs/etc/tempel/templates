;; ~/.config/emacs/etc/tempel/templates

;; Note that templates associated with Tree Sitter-powered modes often result
;; in odd-looking indentation. Hopefully this is fixed as Tree Sitter
;; integration matures. In the meantime, just let Apheleia fix the indentation
;; when you save.

fundamental-mode ;; Available everywhere

(today (format-time-string "%Y-%m-%d"))

prog-mode

(fixme (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "FIXME: ")
(todo (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "TODO: ")
(bug (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "BUG: ")
(hack (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "HACK: ")

emacs-lisp-mode

(defvar "(defvar " (p "NAME") " " (p "VALUE") n> "\"" (p "DOCSTRING") "\")" q)
(defconst "(defvar " (p "NAME") " " (p "VALUE") n> "\"" (p "DOCSTRING") "\")" q)
(defun "(defun " (p "NAME") " (" (p "ARGS") ")" n> "\"" (p "DOCSTRING") "\"" n> (r> "BODY") ")")
(let "(let (" (p "CONDITION") ")" n> (r> "BODY") ")")
(let* "(let* (" (p "CONDITION") ")" n> (r> "BODY") ")")
(if-let "(if-let (" (p "CONDITION") ")" n> (r> "BODY") ")")
(if-let* "(if-let* (" (p "CONDITION") ")" n> (r> "BODY") ")")
(when-let "(when-let (" (p "CONDITION") ")" n> (r> "BODY") ")")
(when-let* "(when-let* (" (p "CONDITION") ")" n> (r> "BODY") ")")
(dolist "(dolist (" (p "CONDITION") ")" n> (r> "BODY") ")")

eshell-mode

(sink (p "COMMAND") " > (my/eshell-sink)" q)
(sink-named (p "COMMAND") " > (my/eshell-sink \"" (p "BUFFER-NAME") "\")" q)

org-mode

(begin "#+begin_" (s name) n> (r> "BODY") n "#+end_" name)
(quote "#+begin_quote" n> (r> "BODY") n> "#+end_quote")
(example "#+begin_example" n> (r> "BODY") n> "#+end_example")
(comment "#+begin_comment" n> (r> "BODY") n> "#+end_comment")
(src "#+begin_src " (p "LANGUAGE") n> (r> "BODY") n> "#+end_src")

go-mode go-ts-mode

(if "if " (p "CONDITION") " {" n> (r> "BODY") n> "}" q)
(if-else "if " (p "CONDITION") " {" n> (r> "BODY") n> "} else {" n> (p "BODY") n> "}" q)
(if-else-if "if " (p "CONDITION") " {" n> (r> "BODY") n> "} else if " (p "BODY") " {" n> (p "BODY") n> "}" q)
(if-err "if err != nil {" n> (r> "BODY") n> "}" q)

rust-mode rust-ts-mode

(dbg "dbg!(" (r> "EXPRESSION") ")" q)
(derive "#[derive(" (r> "TYPE") ")]" q)
(fn "fn " (p "NAME") "(" (p "ARGS") ") {" n> (r> "BODY") n> "}" q)
(fn-return "fn " (p "NAME") "(" (p "ARGS") ") -> " (p "TYPE") " {" n> (r> "BODY") n> "}" q)
(if "if " (p "CONDITION") " {" n> (r> "BODY") n> "}" q)
(if-else "if " (p "CONDITION") " {" n> (r> "BODY") n> "} else {" n> (p "BODY") n> "}" q)
(if-else-if "if " (p "CONDITION") " {" n> (r> "BODY") n> "} else if " (p "BODY") " {" n> (p "BODY") n> "}" q)
(loop "loop {" n> (r> "BODY") n> "}" q)
(main "fn main() {" n> (r> "BODY") n> "}" q)
(main-tokio "#[tokio::main]" n> "async fn main() {" n> (r> "BODY") n> "}" q)
(new "pub fn new(" (p "ARGS") ") -> Self {" n> "Self {}" n> "}" g)
(test "#[test]" n> "fn " p "() {" n> "assert_eq!(1 + 1, 2);" n> "}" q)
(test-mod "#[cfg(test)]" n> "mod tests {" n> "use super::*;" n n> "#[test]" n> "fn it_works() {" n> "assert_eq!(1 + 1, 2);" n> "}" n> "}" q)

;; Local Variables:
;; mode: lisp-data
;; eval: (outline-minor-mode 1)
;; outline-regexp: "[a-z]"
;; End:
